# Основы Git

## Создание Git репозитория

### Создание репозитория в существующем каталоге

    git init
Чтобы добавить существующие файлы в этом каталоге в репозиторий, надо для каждого файла выполнить `git add` 
> Эта команда добавит файлы сначала в индекс

и выполнить `git commit` 
> Эта команда перенесет все что есть в индексе в сам репозиторий

### Клонирование существующиего репозитория

`git clone` - эта команда получит копию всех данных, что есть на сервере. 

    git clone https://github.com/libgit2/libgit2

склонирует репозиторий в папку `libgit2`

    git clone https://github.com/libgit2/libgit2 mylibgit

склонирует репозиторий в папку `mylibgit`

## Запись изменений в репозиторий

Файлы могут быть _отслеживаемыми_ и _неотслеживаемыми_. _Отслеживаемые_ - это те файлы о которых знает Git. _Отслеживаемые_ могут быть неизмененными, измененными и подготовленными к коммиту (проиндексированные). 
> Говорится, что отслеживаемые файлы, это те файлы, которые находятся в последнем снимке состояния проекта. Но снимков может быть много и отслеживаемым файл может стать не только в последнем снимке, а намного в более ранних снимках. Получается, что последний снимок или каждый снимок (коммит) всегда содержит полный слепок всех файлов. Да, наверное это так. Ведь если мы посмотрим на что ссылается коммит, то он ссылается на предыдущий коммит и дерево текущего коммита. Т.е. по этим связям мы можем раскрутить и дойти до всех файлов проекта, т.е. до всех коммитов. Наверное это имеется ввиду, когда говориться, что последний коммит содержит весь слепок проекта. 

### Определение состояния файлов
    git status

Говорит какие файлы неотслеживаемые, отслеживаемые, в каком состоянии отслеживаемые файлы, также говорит, в какой версии сейчас находимся и с какой веткой на сервере она связана, если связана (т.е. за какой удаленной веткой она следит, если следит).

### Отслеживание новых файлов
    git add <Файл> || <Каталог> Если каталог, команда рекурсивно добавить все файлы в индекс из указанного каталога и его подкаталогов
    git add * - добавит в индекс все файлы (тоже самое что и первая команда)

### Индексация измененных файлов
`git add` многофункциональная команда, она предназначена для добавление под версионный контроль новых файлов, для индексирования, для указания файлов с исправленным конфликтом и т.д.
Файл может быть одновременно в индексе и измененным. Но когда будет сделать `commit`, то в репозиторий попадет та версия файла, которая в индексе. Чтобы переписать файл в индексе его новым содержимым который изменен, надо опять выполнить `git add`.

### Сокращенный вывод статуса
`git status -s` или `git status --short`
В левом столбце - статус файла, в правом - модифицирован (изменен) ли он после этого.
?? - не отслеживаемые файлы 
A  - файл в индексе и не модифицирован (изменен)
MM - файл модифицирован, проиндексирован и еще раз модифицирован
 M - файл модифицирован, но не в индексе.

 ### Игнорирование файлов
 Все регулярные выражения для игнорированных файлов перечисляются в `.gitignore`. Этот файл может быть расположен в подкаталогах проекта, т.е. его содержимое будет распространяться только на этот каталог, где он находится.

 ### Просмотр индексированных и неиндексированных изменений
`git diff` показывать path как он есть. Может показать отличия между индексированным файлов и закомичченым в последний раз (`git diff --stage`), также может показать отличия измененного файла в рабочем каталог по сравнению с индексированным этим же файлом - по умолчанию без дополнительных ключей.  
`--stage` и `--cached` идентичны.  
`git difftool` может запустить редактор для просмотра различий.

### Коммит изменений
Коммит сохраняет только состояние индекса. Если запустить просто команду `git commit`, то будет выведено окно для заполенения сообщения. Если запустить команду `git commit -v`, то в окно с сообщением будет добавлен вывод `diff`. После коммита комментированные строки и вывод `diff` будет удален 
>Т.е. `-v` позволяет посмотреть перед коммитом отличие файла в индексе по сравнению с репозиторием. 

Можно без окна, тогда надо `git commit -m <сообщение>`. 

### Игнорирование индексации
    git commit -a
Позволяет автоматически проиндексировать **отслеживаемые** файлы. 
> Если файл не отслеживаемый, то его надо первый раз будет все равно добавить с помощью `git add`.

### Удаление файлов
`git rm` поместит удаляемый файл в индекс и если будет последюущий `commit`, то это файл удалится из репозитория, т.е. не будет отслеживаемым и удалиться из рабочего каталога. Простое удаление файла из рабочего каталога ничего не даст, т.к. он останется отслеживаемым в репозитории.  
Если файл проиндексирован, то его удаление возможно уже с применением флага `-f`. Это сделано для того, чтобы человек более осознанно понимал, что он удаляет файл, содержимое которого проиндексировано, т.е. готово к коммиту (т.е. защита от "дурака").  
`git rm --cached` удалить файл из репозитория, но оставит его в рабочем каталоге, т.е. файл станет не отслеживаемым.

### Перемещение файлов
Git не отслеживает перемещение файлов явно, но "умно" обнаруживает это. `git mv file_from file_to` это эквивалентно командам:

    mv README.md README
    git rm README.md
    git add README

## Просмотр истории коммитов
    git log
    git log -p -2 (-p = --path, показывает diff для коммита)
    --stat (сокращенная статистика)
    --pretty=oneline|short|full|fuller|format (меняет формат вывода, oneline - все коммиты в одну строку и т.д. в сторону все большей информации. --format - форматирует вывод для его автоматического анализа)
Здесь много полезных опции - надо читать!

### Ограничение вывода
`git log --since=2.week` - показать коммиты, сделанные за последние две недели  
`git log -S function_name` - показать коммиты, в которых есть добавление или удаление это строки  
`git log -- path/to/file` - показать коммиты для этого файла  
Здесь много полезных опции - надо читать!

## Операции отмены
`git commit --amend` - затрет последний коммит новым. Если в индексе ничего не появилось, то с помощью этой команды можно будет поменять только сообщения коммита. Запуститься редактор, где будет отображено сообщение предыдущего коммита.  

### Отмена индексации файла
`git reset HEAD <file>` - удаление файла из индекса  
новый аналог `git restore --staged <file>`

### Отмена изменений в файле
`git checkout -- <file>` - возвращает файл в то состояние, которое было до его изменения пользователем, т.е. удаляет изменения в файле.  
Новый аналог `git restore <file>`

## Работа с удаленными репозиториями
Надо уметь добавлять новые, удалять устаревшие, управлять удаленными ветками, объявлять их отслеживаемыми и т.д.

### Просмотр удаленных репозиториев
`git remote` - отобразить список настроенных удаленных репозиториев  
`git remote -v` - показать адреса для чтения и записи, привязынные к репозиториям.  
Origin - имя по умолчанию, которое дается удаленному репозиторию с которого был сделан клон.

### Добавление удаленных репозиториев
`git remote add <shortname> <url>`   
Можно уже существующему удаленному репозиторию таким образом дать альтернативное удобное имя и этим именем пользоваться.  
В ответе команды может быть такое `* [new branch] master -> origin/master`. Это можно интерпретировать так, что ветка `master` на удаленном сервере связана с веткой `origin/master` на твоем локальном компьютере.

### Получение изменений из удалённого репозитория — Fetch и Pull
`git fetch [remote-name]` - забирает данные с удаленного репозитория, но не сливает ни с какой локальной веткой - это надо делать вручную. Тем не менее появятся все ссылки, которые есть в этом удаленном репозитории. Также не будет автоматом настроена локальная ветка для слежения за удаленной веткой. Если есть локальная ветка, которая следит за удаленной веткой, то команда `git pull` автоматом бы получила изменения из удаленной ветки и слила бы их с локальной. `git clone` автоматом бы добавила удаленный репозиторий под именем `origin`, настроила бы локальную ветку `master` на слежение за удаленной веткой `master` и вылил бы все файлы ветки `master` в рабочий каталог. Т.о. вручную надо сделать сначала `git remote add` далее `git fetch` далее создать и настроить локальную ветку на слежение требуемой удаленной ветки, потом сделать `git checkout` и получить все файлы в рабочий каталог. Все это можно сделать одной командой `clone` (может что и напутал!). Причем после `clone` будет создана локальная и настроена на слежение удаленной ветки та ветка, которая в данный момент была HEAD на удаленном сервере.

Можно настроить в настройках Git что делать если нужно слияние: или делать слияние, или делать перебазирование.

### Отправка изменений в удаленный репозиторий (Push)
`git push <remote-name> <branch-name>`  
`git push origin master`

### Просмотр удаленного репозитория
`git remote show origin`

### Удаление и переименование удалённых репозиториев
`git remote rename pb paul`  
`git remote remove paul` - удалить удаленный репозиторий. При этом будут удалены все отслеживаемые ветки и настройки, связанный с данным репозиторием.

## Работа с тегами
Помечают важные коммиты, например выпуск версий.

### Просмотр списка тегов
`git tag`  
`git tag -l "v1.8.5*"` - найти теги по шаблону (--list)

### Создание тегов
Есть теги легковесные и аннотированные.  
Легковесный тег - как ветка которая не изменяется и содержит только хешь коммита.  
Аннотированный тег - полноценный объект, имеет хешь, данные о авторе, почте, дате создания, комментарий и могут быть подписаны. 

### Аннотированные теги
`git tag -a v1.4 -m "my version 1.4"` - сделает тег на текущий коммит  
`git show` - посмотреть внутренности тега (легковесного или аннотированного), из чего он состоит

### Легковесные теги
`git tag v1.4-lw` - сделает тег на текущий коммит  

### Отложенная расстановка тегов
Теги можно установить и на старые коммиты.
`git tag -a v1.2 9fceb02`  

### Обмен тегами
По умолчание `git push` не отправляет на удаленный сервер локальные теги. Это надо делать явно также, как отправлять ветки командой `git push origin <tagname>`  
`git push origin --tags` - отправит все теги махом и легковесные и аннотированные. Отдельно отправить все аннотированные теги можно с помощью `git push <remote> --follow-tags`. Команды отдельно отправить все легковесные теги не существует.

### Удаление тегов
`git tag -d v1.4-lw` - тег с удаленное сервера удален не будет, надо `git push origin :refs/tags/v1.4-lw` - т.е. удаляем как обновляем удаленный тег пустым, или `git push origin --delete <tagname>`.

### Переход на тег
`git checkout <имя_тега>` - это приведет к "detached HEAD". Если в таком состоянии сделать коммит, то тег не передвинеться и коммиту можно будет обратиться только по его хешь тегу, т.к. он не будет закреплен ни за одной веткой. Если надо внести изменения лучше создать ветку на основе тега, но после коммита в эту ветку тег то все равно не сдвинется.

## Псевдонимы в Git
Можно настроить алиасы для любой команды Git. `git config --global alias.co checkout`. С помощью ! можно запускать внешние команды `git config --global alias.visual '!gitk'`. Также можно делать алиас на команды с параметрами `git config --global alias.last 'log -1 HEAD'`

# Ветвление в Git

## О ветвлениях в двух словах

## Основы ветвления и слияния

## Управление ветками

## Работа с ветками

## Удаленные ветки

## Перебазирование
