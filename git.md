# Основы Git

## Создание Git репозитория

### Создание репозитория в существующем каталоге

    git init
Чтобы добавить существующие файлы в этом каталоге в репозиторий, надо для каждого файла выполнить `git add` 
> Эта команда добавит файлы сначала в индекс

и выполнить `git commit` 
> Эта команда перенесет все что есть в индексе в сам репозиторий

### Клонирование существующиего репозитория

`git clone` - эта команда получит копию всех данных, что есть на сервере. 

    git clone https://github.com/libgit2/libgit2

склонирует репозиторий в папку `libgit2`

    git clone https://github.com/libgit2/libgit2 mylibgit

склонирует репозиторий в папку `mylibgit`

## Запись изменений в репозиторий

Файлы могут быть _отслеживаемыми_ и _неотслеживаемыми_. _Отслеживаемые_ - это те файлы о которых знает Git. _Отслеживаемые_ могут быть неизмененными, измененными и подготовленными к коммиту (проиндексированные). 
> Говорится, что отслеживаемые файлы, это те файлы, которые находятся в последнем снимке состояния проекта. Но снимков может быть много и отслеживаемым файл может стать не только в последнем снимке, а намного в более ранних снимках. Получается, что последний снимок или каждый снимок (коммит) всегда содержит полный слепок всех файлов. Да, наверное это так. Ведь если мы посмотрим на что ссылается коммит, то он ссылается на предыдущий коммит и дерево текущего коммита. Т.е. по этим связям мы можем раскрутить и дойти до всех файлов проекта, т.е. до всех коммитов. Наверное это имеется ввиду, когда говориться, что последний коммит содержит весь слепок проекта. 

### Определение состояния файлов
    git status

Говорит какие файлы неотслеживаемые, отслеживаемые, в каком состоянии отслеживаемые файлы, также говорит, в какой версии сейчас находимся и с какой веткой на сервере она связана, если связана (т.е. за какой удаленной веткой она следит, если следит).

### Отслеживание новых файлов
    git add <Файл> || <Каталог> Если каталог, команда рекурсивно добавить все файлы в индекс из указанного каталога и его подкаталогов
    git add * - добавит в индекс все файлы (тоже самое что и первая команда)

### Индексация измененных файлов
`git add` многофункциональная команда, она предназначена для добавление под версионный контроль новых файлов, для индексирования, для указания файлов с исправленным конфликтом и т.д.
Файл может быть одновременно в индексе и измененным. Но когда будет сделать `commit`, то в репозиторий попадет та версия файла, которая в индексе. Чтобы переписать файл в индексе его новым содержимым который изменен, надо опять выполнить `git add`.

### Сокращенный вывод статуса
`git status -s` или `git status --short`
В левом столбце - статус файла, в правом - модифицирован (изменен) ли он после этого.
?? - не отслеживаемые файлы 
A  - файл в индексе и не модифицирован (изменен)
MM - файл модифицирован, проиндексирован и еще раз модифицирован
 M - файл модифицирован, но не в индексе.

 ### Игнорирование файлов
 Все регулярные выражения для игнорированных файлов перечисляются в `.gitignore`. Этот файл может быть расположен в подкаталогах проекта, т.е. его содержимое будет распространяться только на этот каталог, где он находится.

 ### Просмотр индексированных и неиндексированных изменений
`git diff` показывать path как он есть. Может показать отличия между индексированным файлов и закомичченым в последний раз (`git diff --stage`), также может показать отличия измененного файла в рабочем каталог по сравнению с индексированным этим же файлом - по умолчанию без дополнительных ключей.  
`--stage` и `--cached` идентичны.  
`git difftool` может запустить редактор для просмотра различий.

### Коммит изменений
Коммит сохраняет только состояние индекса. Если запустить просто команду `git commit`, то будет выведено окно для заполенения сообщения. Если запустить команду `git commit -v`, то в окно с сообщением будет добавлен вывод `diff`. После коммита комментированные строки и вывод `diff` будет удален 
>Т.е. `-v` позволяет посмотреть перед коммитом отличие файла в индексе по сравнению с репозиторием. 

Можно без окна, тогда надо `git commit -m <сообщение>`. 

### Игнорирование индексации
    git commit -a
Позволяет автоматически проиндексировать **отслеживаемые** файлы. 
> Если файл не отслеживаемый, то его надо первый раз будет все равно добавить с помощью `git add`.

### Удаление файлов
`git rm` поместит удаляемый файл в индекс и если будет последюущий `commit`, то это файл удалится из репозитория, т.е. не будет отслеживаемым и удалиться из рабочего каталога. Простое удаление файла из рабочего каталога ничего не даст, т.к. он останется отслеживаемым в репозитории.  
Если файл проиндексирован, то его удаление возможно уже с применением флага `-f`. Это сделано для того, чтобы человек более осознанно понимал, что он удаляет файл, содержимое которого проиндексировано, т.е. готово к коммиту (т.е. защита от "дурака").  
`git rm --cached` удалить файл из репозитория, но оставит его в рабочем каталоге, т.е. файл станет не отслеживаемым.

### Перемещение файлов
Git не отслеживает перемещение файлов явно, но "умно" обнаруживает это. `git mv file_from file_to` это эквивалентно командам:

    mv README.md README
    git rm README.md
    git add README

## Просмотр истории коммитов
    git log
    git log -p -2 (-p = --path, показывает diff для коммита)
    --stat (сокращенная статистика)
    --pretty=oneline|short|full|fuller|format (меняет формат вывода, oneline - все коммиты в одну строку и т.д. в сторону все большей информации. --format - форматирует вывод для его автоматического анализа)
Здесь много полезных опции - надо читать!

### Ограничение вывода
`git log --since=2.week` - показать коммиты, сделанные за последние две недели  
`git log -S function_name` - показать коммиты, в которых есть добавление или удаление это строки  
`git log -- path/to/file` - показать коммиты для этого файла  
Здесь много полезных опции - надо читать!

## Операции отмены
`git commit --amend` - затрет последний коммит новым. Если в индексе ничего не появилось, то с помощью этой команды можно будет поменять только сообщения коммита. Запуститься редактор, где будет отображено сообщение предыдущего коммита.  

### Отмена индексации файла
`git reset HEAD <file>` - удаление файла из индекса  
новый аналог `git restore --staged <file>`

### Отмена изменений в файле
`git checkout -- <file>` - возвращает файл в то состояние, которое было до его изменения пользователем, т.е. удаляет изменения в файле.  
Новый аналог `git restore <file>`

## Работа с удаленными репозиториями
Надо уметь добавлять новые, удалять устаревшие, управлять удаленными ветками, объявлять их отслеживаемыми и т.д.

### Просмотр удаленных репозиториев
`git remote` - отобразить список настроенных удаленных репозиториев  
`git remote -v` - показать адреса для чтения и записи, привязынные к репозиториям.  
Origin - имя по умолчанию, которое дается удаленному репозиторию с которого был сделан клон.

### Добавление удаленных репозиториев
`git remote <shortname> <url>`   
Можно уже существующему удаленному репозиторию таким образом дать альтернативное удобное имя и этим именем пользоваться.

## Работа с тегами

## Псевдонимы в Git

# Ветвление в Git

## О ветвлениях в двух словах

## Основы ветвления и слияния

## Управление ветками

## Работа с ветками

## Удаленные ветки

## Перебазирование
